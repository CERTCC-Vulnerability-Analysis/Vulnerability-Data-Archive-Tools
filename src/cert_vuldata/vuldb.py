'''
Created on Apr 6, 2016

@author: adh
'''
import os
import json
from dateutil import parser
import sys


def _data_cleaner(d):
    '''
    Json.load will pass the dict to this method before handing it back to the code that
    called it. Be sure to return a dictionary.
    :param d:
    '''
    # This is where you clean up the data after it's read but before it's used
    for k, v in d.items():
        if "Date" in k:
            if len(v):
                try:
                    d[k] = parser.parse(v)
                except ValueError:
                    d[k] = None
    return d

DOT_INTERVAL = 1


class VulDb(dict):

    def __init__(self, path_to_data=None, data_cleaner=None, quiet=True):
        self.path_to_data = path_to_data
        if data_cleaner is None:
            self.data_cleaner = _data_cleaner
        else:
            self.data_cleaner = data_cleaner
        self.quiet = quiet

    def load(self):
        '''
        Loads the data from self.path_to_data
        '''
        vulcount = 0
        if not self.quiet:
            sys.stdout.write('Loading vulnerability data: ')
            sys.stdout.write('0')
            last_len = 1

        for dirpath, _dirnames, filenames in os.walk(self.path_to_data):
            vul_files = [os.path.join(dirpath, f)
                         for f in filenames if f.startswith('vu_')]
            vendor_files = [
                os.path.join(dirpath, f) for f in filenames if f.startswith('vendor_')]

            if len(vul_files) == 0:
                # skip ahead on dirs with no vul files
                continue

            for vul_file in vul_files:
                with open(vul_file, 'r') as fp:
                    data = json.load(fp, object_hook=self.data_cleaner)
                    key = data['ID']
                    self[key] = data
                    vulcount += 1

            # add vendor key
            vendors = {}

            if not self.quiet:
                if not vulcount % DOT_INTERVAL:
                    counter_str = str(vulcount)
                    sys.stdout.write('\b' * last_len)
                    sys.stdout.write(counter_str)
                    last_len = len(counter_str)
                    sys.stdout.flush()

            for vendor_file in vendor_files:
                with open(vendor_file, 'r') as fp:
                    data = json.load(fp, object_hook=self.data_cleaner)
                    vendor_key = data['VendorRecordID']
                    vendors[vendor_key] = data

            self[key][u'VendorRecords'] = vendors.values()

        if not self.quiet:
            print

    def find_affected_vendor(self, vendor):
        vn = vendor.lower()
        results = []
        for vul_id, vul_data in self.iteritems():
            hit = False
            vendor_recs = vul_data['VendorRecords']
            for v in vendor_recs:
                if vn in v['Vendor'].lower():
                    if 'affected' in v['Status'].lower():
                        hit = True
                        break
                    elif 'vulnerable' in v['Status'].lower():
                        hit = True
                        break
            if hit:
                results.append(vul_id)
        return results

